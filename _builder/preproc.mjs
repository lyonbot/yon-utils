import { readFile, writeFile } from 'node:fs/promises';
import { dirname, resolve, join } from 'node:path';
import ts from 'typescript';
import glob from 'glob';

const root = resolve(dirname(import.meta.url.slice('file://'.length)), '..')
const files = glob.sync('*/*.ts', {
  ignore: ['node_modules/**/*', '*/*.{test,spec,stories,story}.*', '*/*.d.ts', '*/index.ts'],
  root,
})

const dirs = Object.create(null);
for (const fullPath of files) {
  const [, dir, file] = /^(\w+)\/(.*)\.\w+$/.exec(fullPath);
  if (!dirs[dir]) dirs[dir] = [];
  dirs[dir].push(file);
}

for (const dir in dirs) {
  const modules = dirs[dir].sort()
  const content = '// this file is automatically generated. do not modify\n\n' + modules.map(it => `export * from "./${it}";\n`).join('')
  await writeFile(join(root, dir, 'index.ts'), content)
}

// ----------------------------------------------------------------
// generate 

const markdownFilePath = join(root, 'README.md');
const oldMarkdown = await readFile(markdownFilePath, 'utf8');
const markdownStartMark = '<!-- auto generate begin -->\n\n'
const markdownEndMark = '\n<!-- auto generate end -->'

const markdownBegin = oldMarkdown.slice(0, oldMarkdown.indexOf(markdownStartMark) + markdownStartMark.length)
const markdownEnd = oldMarkdown.slice(oldMarkdown.indexOf(markdownEndMark))

// -------------

let newMarkdown = markdownBegin
for await (const content of genAPIDoc()) newMarkdown += content + '\n'
newMarkdown += markdownEnd
await writeFile(markdownFilePath, newMarkdown)

async function* genAPIDoc() {
  const tsPath = resolve(root, 'tsconfig.json')
  const tsConfig = ts.parseConfigFileTextToJson(tsPath, await readFile(tsPath, 'utf8')).config
  const tsCompilerOptions = ts.convertCompilerOptionsFromJson(tsConfig.compilerOptions).options
  let program = ts.createProgram(files.map(x => resolve(root, x)), tsCompilerOptions);
  let checker = program.getTypeChecker();

  for (const dir in dirs) {
    for (const modulePath of dirs[dir]) {
      yield '<br />\n'
      yield `## ðŸ§© ${dir}/${modulePath}\n`;

      const sf = program.getSourceFile(resolve(root, dir, `${modulePath}.ts`));
      const sym = checker.getSymbolAtLocation(sf);

      for (const s of checker.getExportsOfModule(sym)) {
        let decl = s.getDeclarations().find(x => ts.isFunctionLike(x))
        if (!decl) continue;

        let funcType = checker.getTypeAtLocation(decl)
        let callSignature = funcType.getCallSignatures().slice(-1)[0]

        let signatureText = (
          decl.name.getText()
          + '('
          + decl.parameters.map(it => {
            let ans = it.name.getText();
            if (it.questionToken || it.initializer) ans = `${ans}?`;
            if (it.dotDotDotToken) ans = `...${ans}`;
            return ans
          }).join(', ')
          + ')'
        )

        yield `### \`${signatureText}\``
        yield ''

        let returnDoc = ''
        let exampleDoc = ''

        const paramsDoc = Object.create(null); {
          for (const it of [...callSignature.getJsDocTags(), ...s.getJsDocTags()]) {
            if (it.name === 'param') {
              const name = it.text?.find(x => x.kind === 'parameterName')?.text
              if (!name) continue

              paramsDoc[name] = joinText(it.text).slice(name.length).trim()
            }

            if (it.name === 'return' || it.name === 'returns') {
              returnDoc = joinText(it.text)
            }

            if (it.name === 'example') {
              exampleDoc = joinText(it.text)
            }
          }
        }

        for (const param of callSignature.getParameters()) {
          const decl = param.getDeclarations()[0]
          const type = checker.getTypeAtLocation(decl)
          const name = param.getName()
          const doc = paramsDoc[name] || ''

          yield '- **' + name + '**: `' + checker.typeToString(type) + '` ' + doc.replace(/\n/g, '\n  ')
          yield ''
        }

        {
          const retType = callSignature.getReturnType()
          const doc = returnDoc

          yield '- Returns: `' + checker.typeToString(retType) + '` ' + doc.replace(/\n/g, '\n  ')

          yield ''
        }

        yield joinText(s.getDocumentationComment())
        yield ''

        if (exampleDoc) {
          yield '#### Example\n'
          yield exampleDoc
        }

        yield ''
      }
    }
  }
}

function joinText(syms) {
  return String(syms.map(x => x.text || '').join('\n\n')).trim()
}

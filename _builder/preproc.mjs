import { readFile, writeFile } from 'node:fs/promises';
import { dirname, resolve, join } from 'node:path';
import ts from 'typescript';
import glob from 'glob';

const root = resolve(dirname(import.meta.url.slice('file://'.length)), '..')
const files = glob.sync('*/*.ts', {
  ignore: ['node_modules/**/*', '*/*.{test,spec,stories,story}.*', '*/*.d.ts', '*/index.ts', '_browser_playground/**/*'],
  root,
})

const dirs = Object.create(null);
for (const fullPath of files) {
  const [, dir, file] = /^(\w+)\/(.*)\.\w+$/.exec(fullPath);
  if (!dirs[dir]) dirs[dir] = [];
  dirs[dir].push(file);
}

for (const dir in dirs) {
  const modules = dirs[dir].sort()
  const content = '// this file is automatically generated. do not modify\n\n' + modules.map(it => `export * from "./${it}.js";\n`).join('')
  await writeFile(join(root, dir, 'index.ts'), content)
}

{
  const dirIds = Object.keys(dirs)
  const content = '// this file is automatically generated. do not modify\n\n' + dirIds.map(it => `export * from "./${it}/index.js";\n`).join('')
  await writeFile(join(root, 'index.js'), content)
  await writeFile(join(root, 'index.d.ts'), content)
}

// ----------------------------------------------------------------
// generate 

const markdownFilePath = join(root, 'README.md');
const oldMarkdown = await readFile(markdownFilePath, 'utf8');
const markdownStartMark = '<!-- auto generate begin -->\n\n'
const markdownEndMark = '\n<!-- auto generate end -->'

const markdownBegin = oldMarkdown.slice(0, oldMarkdown.indexOf(markdownStartMark) + markdownStartMark.length)
const markdownEnd = oldMarkdown.slice(oldMarkdown.indexOf(markdownEndMark))

// -------------

let newMarkdown = ''
let toc = Object.fromEntries(Object.keys(dirs).map(d => [d, []]))
let lastLine
for await (const content of genAPIDoc(toc)) {
  if (content.isTOCItem) {
    tocItems.push(content.isTOCItem)
    continue
  }

  if (!content && !lastLine) continue
  lastLine = content
  newMarkdown += content + '\n'
}

newMarkdown =
  `${markdownBegin}

## ToC

| module | methods |
|---------|:--------|
${Object.entries(toc).map(([dir, items]) => `| ${dir} | ${items.map(x => `[${x}](#fn-${x})`).join(' / ')} |`).join('\n')}

${newMarkdown}
${markdownEnd}`
await writeFile(markdownFilePath, newMarkdown)

async function* genAPIDoc(toc) {
  const tsPath = resolve(root, 'tsconfig.json')
  const tsConfig = ts.parseConfigFileTextToJson(tsPath, await readFile(tsPath, 'utf8')).config
  const tsCompilerOptions = ts.convertCompilerOptionsFromJson(tsConfig.compilerOptions).options
  let program = ts.createProgram(files.map(x => resolve(root, x)), tsCompilerOptions);
  let checker = program.getTypeChecker();

  for (const dir in dirs) {
    for (const modulePath of dirs[dir]) {
      yield '<br />\n'
      yield `## ðŸ§© ${dir}/${modulePath}\n`;

      const sf = program.getSourceFile(resolve(root, dir, `${modulePath}.ts`));
      const sym = checker.getSymbolAtLocation(sf);

      /**
       * @param {string} funcName
       * @param {ts.Signature} callSignature
       * @param {Object} opts
       * @param {(type: ts.Type) => boolean} [opts.listPropertiesOfType]
       */
      function getMethodDoc(funcName, callSignature, {
        extraJSDocTags = [],
        listPropertiesOfType,
      }) {
        const decl = callSignature?.getDeclaration() // exact the FunctionLike expression or decl
        if (!decl) return null

        const signatureText = (
          funcName
          + '('
          + decl.parameters.map(it => {
            let ans = it.name.getText();
            if (it.questionToken || it.initializer) ans = `${ans}?`;
            if (it.dotDotDotToken) ans = `...${ans}`;
            return ans
          }).join(', ')
          + ')'
        )

        const paramsDocLUT = Object.create(null);
        let returnDoc = ''
        let exampleDoc = ''

        // extract information from JSDoc
        {
          for (const it of [...callSignature.getJsDocTags(), ...extraJSDocTags]) {
            if (it.name === 'param') {
              const name = it.text?.find(x => x.kind === 'parameterName')?.text
              if (!name) continue

              paramsDocLUT[name] = joinText(it.text).slice(name.length).trim()
                .replace(/^-\s*/, '')    // TSDoc may require a extra " - "
            }

            if (it.name === 'return' || it.name === 'returns') {
              returnDoc = joinText(it.text)
            }

            if (it.name === 'example') {
              exampleDoc = joinText(it.text)
            }
          }
        }

        // prepend type info to `returnDoc`
        {
          const type = callSignature.getReturnType()
          const decl = type.getSymbol()?.getDeclarations()?.[0]
          const doc = indent(returnDoc, '  ', 'â€” ')

          const subProperties = (!listPropertiesOfType || listPropertiesOfType(type))
            ? propertiesToMarkdownList(decl, sf)
            : ''

          returnDoc = `Returns: \`${typeToString(type, decl)}\` ${doc}\n${subProperties}`.trim()
        }

        // generate params list
        const paramsDoc = Array.from(callSignature.getParameters(), param => {
          let decl = param.getDeclarations()[0]
          let type = checker.getTypeAtLocation(decl)
          let name = param.getName()
          const doc = indent(paramsDocLUT[name], '  ', 'â€” ')

          if (decl.questionToken || decl.initializer) {
            name += '?'
            type = type.getNonNullableType()
          }

          const subProperties = (!listPropertiesOfType || listPropertiesOfType(type))
            ? propertiesToMarkdownList(type?.getSymbol()?.getDeclarations()?.[0], sf)
            : ''

          return `**${name}**: \`${typeToString(type, decl)}\` ${doc}\n${subProperties}`.trim()
        })

        return {
          funcName,

          /** like `foobar(a, b, ...c)` */
          signatureText,

          /** a string starts with `Returns: type - info` */
          returnDoc,

          /** optional, example extracted from jsdoc */
          exampleDoc,

          /** each item is like `**foobar**: type - info` */
          paramsDoc,
        }
      }

      for (const s of checker.getExportsOfModule(sym)) {
        let funcType = checker.getTypeOfSymbolAtLocation(s, s.getDeclarations()[0])  // this temp "decl" could be a variableDeclarator
        let callSignature = funcType?.getCallSignatures().slice(-1)[0]

        let isClass = '';
        if (!callSignature) {
          callSignature = funcType.getConstructSignatures().slice(-1)[0]
          isClass = 'new '
        }

        let decl = callSignature?.getDeclaration() // exact the FunctionLike expression or decl

        if (!decl) continue;
        if (ts.isTypeNode(decl)) continue;  // ignore "type XXX = ..."

        const funcName = s.getName()
        const parsed = getMethodDoc(funcName, callSignature, { extraJSDocTags: s.getJsDocTags() })
        if (!parsed) continue;

        const { signatureText, returnDoc, exampleDoc, paramsDoc } = parsed

        toc[dir].push(funcName)
        yield `<a id="fn-${funcName}"></a>`
        yield `### \`${isClass}${signatureText}\``
        yield ''

        for (const param of paramsDoc) {
          yield indent(param, '  ', '- ')
          yield ''
        }

        if (!isClass) {
          yield indent(returnDoc, '  ', '- ')
          yield ''
        }

        yield joinText(s.getDocumentationComment())
        yield ''

        if (exampleDoc) {
          yield '#### Example\n'
          yield exampleDoc
        }

        const classType = !!isClass && callSignature.getReturnType()
        if (classType && classType.isClass()) {
          // yield '#### Class ' + funcName;
          yield '<details>'
          yield '<summary>\n<em>ðŸ“– show members of <code>' + funcName + '</code> &raquo;</em>\n</summary>'
          yield ''
          for (const s of classType.getProperties()) {
            let prettyName = s.getName()

            let decl = s.getDeclarations()[0]
            if (ts.getCombinedModifierFlags(decl) & ts.ModifierFlags.Private) continue;
            if (decl.getSourceFile() !== sf) continue;  // maybe inherited from stdlib?

            let funcType = checker.getTypeOfSymbolAtLocation(s, decl)  // this temp "decl" could be a variableDeclarator
            let callSignature = funcType?.getCallSignatures().slice(-1)[0]
            let parsed = getMethodDoc(s.getName(), callSignature, {
              extraJSDocTags: s.getJsDocTags(),
              listPropertiesOfType(type) {
                return type.aliasSymbol !== classType.aliasSymbol
              }
            })
            if (parsed) prettyName = parsed.signatureText

            yield `#### ${funcName} # ${prettyName}`
            if (parsed) {
              for (const param of parsed.paramsDoc) {
                yield indent(param, '  ', '- ')
                yield ''
              }
              yield indent(parsed.returnDoc, '  ', '- ')
              yield ''
            } else {
              yield `- Type: \`${typeToString(funcType, decl)}\``
              yield ''
            }
            yield joinText(s.getDocumentationComment())
            yield ''
          }
          yield '';
          yield '</details>'
          yield '';
        }

        yield ''
      }
    }
  }

  /**
   * 
   * @param {ts.Type} type 
   * @param {*} decl 
   * @returns 
   */
  function typeToString(type, decl) {
    if (decl && ts.isObjectLiteralExpression(decl)) {
      return `{ ${
        // simply listing properties
        decl.properties
          .map(x => {
            let name = x.name?.getText()
            if (!name) return ''
            if (x.questionToken) name += '?'

            return name
          })
          .filter(Boolean)
          .join(', ')
        } }`
    }
    return checker.typeToString(type)
  }

  /** @param {ts.Node} node */
  function propertiesToMarkdownList(node, limitToSourceFile) {
    if (!node || !(ts.isInterfaceDeclaration(node) || ts.isObjectLiteralElementLike(node) || ts.isObjectLiteralExpression)) return ''

    const type = checker.getTypeAtLocation(node)
    const props = type.getProperties()

    const ans = [];
    for (const prop of props) {
      const decl = prop.getDeclarations()[0]
      if (limitToSourceFile !== decl.getSourceFile()) continue  // not from this project

      let type = checker.getTypeAtLocation(decl)
      let name = prop.getName()
      if (type.isUnion() && type.types.some(subType => subType.flags & (ts.TypeFlags.Undefined | ts.TypeFlags.Null))) {
        name += '?'
        type = type.getNonNullableType()
      }

      const doc = indent(joinText(prop.getDocumentationComment()), '  ', 'â€” ')
      ans.push(`- **${name}**: \`${checker.typeToString(type)}\` ${doc}`)
    }

    return ans.join('\n\n')
  }
}

function joinText(syms) {
  return String(syms.map(x => x.text || '').join('\n\n')).trim()
}

function indent(str, indent, indentForFirstLine = indent) {
  if (!str) return ''

  str = str.replace(/^/gm, indent)
  str = (indentForFirstLine || '') + str.slice(indent.length)
  return str
}
